# Sudoku Design Spec

### Sections
1. User interface
2. Inputs and outputs
3. Functional decomposition into modules
4. Pseudo code
5. Dataflow through modules
6. Major data structures
7. Testing plan


### User Interface
./sudoku create or ./sudoku solve

We anticipate the following user interface:

The user will interact with the sudoku module when calling the program to execute with `./sudoku`. The program takes 1-2 arguments.
```
./sudoku mode difficulty_level
```
where *mode* is either “create” or “solve” to either create a sudoku puzzle or solve it, and 
*difficulty_level* is an optional parameter that takes an integer for the sudoku’s difficulty level to create. If the parameter isn’t given, the difficulty level is automatically 1.

For example:
```
./sudoku create 3
```
The two modes––create and solve––will be the two acceptable command-line arguments that dictate how the program will run. The argument `create` will prompt the program to build a new sudoku puzzle while the argument `solve` will instruct the program to solve a sudoku puzzle that the user is required to provide through stdin.

Beyond calling the program, we anticipate further interactions with the user, specifically relating to setting the difficulty of sudoku puzzles generated by the ‘creator’. The program will prompt the user to select a difficulty level, and the creator will design a puzzle accordingly.
***This last part is if we decide to implement a set_difficulty feature


### Pseudo Code

* Parse Arguments
    * Ensure 2 arguments, 2nd argument is either “solve” or “create”
    * If ./sudoku solve, store the given puzzle in sudoku_array
* Make Solver
    * Iterate through every empty slot and fill the slot’s bag with possible answers. If there is only one possible answer in bag, set the slot’s number to that answer and set the boolean representing a set slot to true
    * Then, iterate through remaining empty slots. Extract a number from the bag of possible answers and set the slot’s number to that answer. Continue iterating through empty slots until puzzle is finished or puzzle reaches a slot where no number is possible. 
    * If puzzle reaches a slot where no number is possible, backtrack.
    * When backtracking, the puzzle with return to the previous slot and call bag_extract() again to try a new number.
    * Print sudoku 
* Make Creator
    * Fill in a puzzle by putting random numbers in each slot until the puzzle is finished or there is a slot where no number can be put
    * Use backtracking if there is a slot with no possible answer
    * Once the puzzle is finished, select a certain number of random slots. If removing the slot results in a puzzle with more than one possible solution, put the number back and pick a new random slot. Once enough slots have been removed, return the puzzle to the caller
    * Print sudoku
