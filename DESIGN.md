# Sudoku Design Spec

### Sections
1. User interface
2. Inputs and outputs
3. Functional decomposition into modules
4. Pseudo code
5. Dataflow through modules
6. Major data structures
7. Testing plan


### User Interface

./sudoku create or ./sudoku solve

We anticipate the following user interface:

The user will interact with the sudoku module when calling the program to execute with `./sudoku`. The program takes 1-2 arguments.
```
./sudoku mode difficulty_level
```
where *mode* is either “create” or “solve” to either create a sudoku puzzle or solve it, and 
*difficulty_level* is an optional parameter that takes an integer for the sudoku’s difficulty level to create. If the parameter isn’t given, the difficulty level is automatically 1.

For example:
```
./sudoku create 3
```
The two modes––create and solve––will be the two acceptable command-line arguments that dictate how the program will run. The argument `create` will prompt the program to build a new sudoku puzzle while the argument `solve` will instruct the program to solve a sudoku puzzle that the user is required to provide through stdin.

Beyond calling the program, we anticipate further interactions with the user, specifically relating to setting the difficulty of sudoku puzzles generated by the ‘creator’. The program will prompt the user to select a difficulty level, and the creator will design a puzzle accordingly.
***This last part is if we decide to implement a set_difficulty feature


### Inputs and Outputs

Inputs and outputs will be described according to the two major modes: ‘create’ and ‘solve’.

*Create*
The ‘creator’ will take no input aside from when calling the program to execute. It will output a newly created puzzle to stdout.

*Solve*
The ‘solver’ will take a sudoku puzzle through prompted user input through stdin. The program will then output the solved puzzle through stdout.


### Functional Decomposition Into Modules

We anticipate the following modules and/or functions:

**Sudoku**

*build_sudoku*, which reads a sudoku puzzle from stdin and converts it to the board struct.

*solver*, which will take a sudoku puzzle and use a recursive backtracking method to solve the puzzle.

*sudoku_solve*, which initializes the board and calls on the *solver* to solve the puzzle.

*creator*, which will generate a new, solveable sudoku puzzle and output it to stdout.

*count_solutions*, which checks how many solutions the current board has, verifying that the final sudoku has a unique solution.

*compare_solutions*, which is a helper function for *count_solutions* that checks if a sudoku board solution is different from another.

**Board**

*board_new*, which initializes a new board struct to hold a sudoku puzzle.

*board_set*, which sets a specificed slot to a given number.

*board_get*, which gets the number at a specified slot.

*board_print*, which prints the final board struct to stdout.

*board_iterate*, which iterates through every slot on the board and applies a given function to each.

*valid_input*, which checks if the most recently inserted number works is valid (unique number 1-9 horizontally, vertically, and per block).

*empty_location*, which loops through the board––from the top left to the bottom right––and returns true when it finds an empty slot. It also adjusts the given *row* and *col* variables such that they will hold the corresponding values of the empty slot.

*board_delete*, which deletes the struct and its comprising values.


### Pseudo Code

* Parse arguments
   * Ensure 2 arguments, 2nd argument is either "solve" or "create"

* Solver:
* Read from stdin to receive sudoku puzzle
* Recurse through every slot that is not given by the puzzle:
    * Starting from one and going until 9:
        * Check if the number fits the current puzzle (row, col, box)
        * If it fits, continue to the next non-given slot and repeat
        * If it doesn't fit, move onto the next number
    * If none of the numbers work, backtrack to previous non-given slot and continue where left off.

* Creator:
* Fill in a puzzle by putting random numbers in each slot until the puzzle is finished or there is a slot where no number can be put
* Use backtracking if there is a slot with no possible answer
* Once the puzzle is finished, select a certain number of random slots. If removing the slot results in a puzzle with more than one possible solution, put the number back and pick a new random slot. Once enough slots have been removed, return the puzzle to the caller
* Print sudoku


### Dataflow Through Modules

Solver: sudoku_solve → build_sudoku → solver → empty_location → valid_input → board_print

The `solver` will use *sudoku_solve*, which calls on *build_sudoku* to read from stdin and create the sudoku board. *sudoku_solve*, after creating the board, will then call on *solver* to recursively input numbers and use a backtracking method to solve the puzzle. *solver* will use *empty_location* to find the next empty slot that has to be filled as well as *valid_input* to check if a particular number fits into the noted slot. Once the *solver* has successfully completed the puzzle, *board_print* will output to stdout the finished puzzle.

Creator: → valid_input → compare_solutions → print_sudoku

The `creator` will call *creator*, which will use *valid_input* to make a properly formatted and randomized Sudoku puzzle. Then, `creator` will select slots at random, remove the number held there, and call *count_solutions*. If there is more than one solution, `creator` will put the number back into the slot and try a new slot. `creator` will continue this pattern until enough slots are empty (as specified by the difficulty level). Then, *print_sudoku* will display to stdout the solutions of the puzzle.


### Major Data Structures

We anticipate the following data structures:

*board*
This struct represents the entire sudoku board. It will hold an array of 9 arrays of 9 slots each, which holds all the tiles on the sudoku board.


### Testing Plan

Unit Testing
* Test *valid_input* for cases which should return a valid input and cases which should not
* Test *count_solutions*
* Test *read_puzzle*
* Test *print_puzzle*
* Test ./sudoku create, printing out the intermediate solved puzzle and then the final puzzle with numbers taken out
* Test ./sudoku solve for a unique puzzle, printing out the input puzzle and then printing out the final puzzle


Integration Testing
* Test for command-line arguments
* Test with incorrect number of arguments
* Test with no difficulty level
* Test with invalid difficulty level
* Test ./sudoku solve with a puzzle with one solution
* Test ./sudoku solve with a puzzle with multiple solutions
* Valgrind ./sudoku create
* Valgrind ./sudoku solve 


Fuzz Testing
* Fuzz testing will use ./sudoku create and solve to create random puzzles and test ./sudoku solve's ability to solve them

